import bodyParser from 'body-parser'
import express from 'express'
import rules from './rules.json'
import * as utils from '../utils/checkAgainstsRules'
import { param } from 'express/lib/request'

export default function (app) {
  app.set('port', process.env.PORT || 3000)
  app.use(express.json())
  app.use(bodyParser.urlencoded({ extended: true }))
}

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
  const method = req.method.toLowerCase()
  const reqUrl = req.originalUrl.split('?')[0]
  const currentRequest = rules.paths[reqUrl][method]

  if (currentRequest.hasOwnProperty('parameters')) {
    const requestBody = req.body
    const queryString = req.query

    try {
      currentRequest.parameters.map(parameter => {
        if (parameter.in === 'body') {
          const currenParamProps = parameter.schema.properties
          Object.keys(currenParamProps).map(paramKey => {
            return utils.checkAgainstRules(
              requestBody,
              paramKey,
              currenParamProps[paramKey].type,
              Object.keys(currenParamProps)
            )
          })
        } else if (parameter.in === 'query') {
          return utils.checkAgainstRules(
            queryString,
            parameter.name,
            parameter.type,
            
          )
        }
      })
    } catch (e) {
      return res.status(400).json({ message: e.message })
    }
  }

  return next()
}
